=head1 NAME

DB_File FAQ - DB_File Frequently Asked Questions

=head1 DESCRIPTION

This file lists some of the common questions that have arisen.

Some of these questions are not specific to DB_File, but are included
here because they come up from time to time in my DB_File mailbox.

=head1 GENERAL

=over 5

=item B<1.>

B<What is the latest version of Berkeley DB?>

At the time of writing this file, 1.85.

Berkeley DB is available at your nearest CPAN archive (see
L<perlmod/"CPAN"> for a list) in F<src/misc/db.1.85.tar.gz>, or via the
host F<ftp.cs.berkeley.edu> in F</ucb/4bsd/db.tar.gz>.

If you are running IRIX, then get Berkeley DB from
F<http://reality.sgi.com/ariel>. It has the patches necessary to
compile properly on IRIX 5.3. 

A major upgrade of Berkeley DB is in progress. No date is currently
available for its release.

=item B<2.>

B<What is the latest version of DB_File?>

DB_File ships with Perl itself, so the latest copy of Perl is the place
to look. The current version of Perl is 5.002. It ships with DB_File
1.01.

=item B<3.>

B<How do I build/install DB_File after Perl itself?>

B<Installing DB_File after Perl's Configure has been run.>

NB - upgrading Berkeley DB.

There are two different cases to consider.

Firstly, the case where Berkeley DB I<is> already installed when Perl
was built, but a new version has subsequently been installed.

Secondly, the case where Berkeley DB is I<not> installed at all when
Configure is run.

If you have build and installed Perl wi

The problem with this is that the C<Configure> script that is run as
part of the Perl build process

Building DB_File after Perl has already been installed is complicated
by the fact that the Configure script is used to determine some
features of the version of Berkeley DB that is installed on the system.
If Berkeley DB is not available when Configure is run, a default set of
values will be assumed.

If DB_File is built after the Configure script has been run, it 

The safest way to achieve the task is to reconfigure and build Perl
again.

=back

=head1 COMMON PROBLEMS


=over 5

=item B<1.>

figure out the error that is printed when DB_File.pm has been
installed, but the .so file has not.

plus the error when the pm & .so exist, but libdb.so doesn't.

=item B<1.>

B<What does "Invalid Argument" mean?>

Pat Answer: An Argument is Invalid.

You are likely to get this error message when one of the parameters in
the C<tie> call is wrong. Unfortunately there are quite a few
parameters to get wrong, so it can be difficult to figure out which one
is is.

The most common reported reason for getting this error is forgetting to
include the C<Fcntl> module in your script. Reminder: the C<Fcntl>
module contains the file access flag symbols, e.g. C<O_RDWR>,
C<O_CREAT>.

For example, say you have a script like this: 

    use DB_File ;
    $filename = "abcd" ;
    tie %h, "DB_File", $filename, O_RDWR|O_CREAT, 0640, $DB_HASH 
	or die "Cannot open $filename: $!\n" ;

Because neither of the two C<O_*> symbols are defined, they will both
have the evaluate to 0.

So the tie line will actually be equivalent to this:

    tie %h, "DB_File", $filename, 0, 0640, $DB_HASH
	or die "Cannot open $filename: $!\n" ;

This particular problem can be caught at compile time by specifing
C<use strict>. As an illustration, if the script above was made strict,
like this:

    use strict ;
    use DB_File ;
    use vars qw(%h $filename) ;
    tie %h, "DB_File", $filename, O_RDWR|O_CREAT, 0640, $DB_HASH ;

The following error messages would be printed:

    Bareword "O_RDWR" not allowed while "strict subs" in use at bad line 4.
    Bareword "O_CREAT" not allowed while "strict subs" in use at bad line 4.


The second most common reason is using the wrong flags. Note that a
database cannot be opened C<O_WRONLY>.


Here are some of the common reasons you may get the error:

If 
Here are some of the reasons you may get the error:

B<HASH>

1. flags is O_WRONLY

2. bsize > MAX_BSIZE

3. lorder != (BIG_ENDIAN or LITTLE_ENDIAN)

The 
This error message is encountered when the C<tie> call fails.

This error message is used by Berkeley DB as catch all which means
"There is something wrong". You will encounter it 

Some of the common reasons for getting this error are:


In your case the 'something' that is wrong is that you are trying
to open a DB file wothout closing it first.

Normally the untie will close the DB file for you, in this case it
won't.

--

I've just spent many hours tracing a problem I was having with
the DB code (via Paul's Perl5 DB_File module).

If you ^C a process which has a DB file open and then try to open that
file in a later process without O_TRUNC you get the not very helpful
message 'Invalid argument' (via errno).


BTREE

1. Any flag apart from R_DUP
2.                 if (b.psize &&
                    (b.psize < MINPSIZE || b.psize > MAX_PAGE_OFFSET + 1 ||
                    b.psize & sizeof(indx_t) - 1))

3. minkeypage spacified and < 2

4. lorder != (BIG_ENDIAN or LITTLE_ENDIAN)

5. O_ not any of O_RDONLY, O_RDWR (note O_WRONLY is not allowed)



RECNO

1. and flag other than R_FIXEDLEN | R_NOKEY | R_SNAPSHOT specified

2. reclen == 0

3. flags any other than O_RDONLY or O_RDWR


=item B<2.>

B<What does C<'Bareword "DB_File" not allowed'> mean? >

You will encounter this particular error message when you have a C<use
strict> in your script. Consider this script:

    use strict ;
    use DB_File ;
    use vars qw(%x) ;
    tie %x, DB_File, "filename" ;

Running it produces this error:

    Bareword "DB_File" not allowed while "strict subs" in use 

To get around this error, place the word C<DB_File> in either single or
double quotes, like this:

    tie %x, "DB_File", "filename" ;

Although it might seem like ... it is really worth the effort of having
a <use strict> in all your scripts.

=item B<3.>

Make sure any references to the inner object are destroyed before the
call to untie.

This one can be tricky to spot...

=item B<5.>

using default flag O_RDWR on new file and wondering why no database
was created.

   need O_RDWR and O_CREAT.


=item B<6.>

B<Using a database in both a C and a Perl application>

B<Why can't I access the database I created in C using DB_File?>

B<Why can't I access the database I created in DB_File using C?>

Simple Answer: You can, as long as you remember that Perl does not
terminate strings with a NULL character, wheras C does.

Why can't I access the database I created in C?

I have a DB file created by a C program and I cannot access any of the
records

The usual reason for this problem is Perl does not terminate strings
with \0

The usual reason people ask this question is that they forget that C
will terminate strings witha NULL character, but Perl doesn't.

Most of the standard string functions in C assume that the string is
NULL terminated. Perl does not terminate strings with a NULL character.

If you want the database to be I<C compatable>, you can explicitly add
the NULL character yourself.

    $X{"$key\0"} = "abcd\0" ;


=item B<7.>

B<What bugs are there?>

cf 217 229
221 223
231
249 250 251 254
351 357
373->378

=item B<8.>

B<Problem with RECNO>

Tied arrays aren't fully supported yet.

cf 135


=item B<9.>

B<Limits on the size of databases/keys/values.>

=item B<9.>

B<Why is my database file empty?>

You forgot to use O_CREAT.

=item B<10.>

B<Caching>

=item B<11.>

B<Why does my database have part of a Perl script in it?>

Simple answer: Berkeley DB doesn't clear buffers allocated from dynamic
memory before using them.

If you look at the contents of a database file created by DB_File,
there can sometimes be part of a Perl script included in it.

This happens because Berkeley DB uses dynamic memory to allocate
buffers which will subsequently be written to the database file. Being
dynamic, the memory could have been used for anything before DB
malloced it. As DB doesn't clear the memory once it has been allocated,
the unused portions will contain random junk. In the case where a Perl
script gets written to the database, the random junk will correspond to
an area of dynamic memory that happened to be used during the
compilation of the script.

Unless you don't like the possibility of there being part of your Perl
scripts embedded in a database file, this is nothing to wory about.

=back 4

=head1 TECHNIQUES

=over 5

=item B<1.>

B<How do I store complex data structures in DB?>

Simple Answer: You cannot I<directly> store complex Perl data structures
in in a Berkeley DB database.

Although you cannot store a Perl data structure in a Berkeley DB
database, there is a module which can let you do this.

MLDBM Data::Dumper

=item B<2.>

B<How do I access duplicate keys?>

=head2 Duplicate keys BTREE

The BTREE file type in Berkeley DB optionally allows a single key to be
associated with an arbitrary number of values. This option is enabled by
setting the flags element of C<$DB_BTREE> to R_DUP when creating the
database.

There are some difficulties in using the tied hash interface if you
want to manipulate a BTREE database with duplicate values. Consider
this code:

    use DB_File ;
    use Fcntl ;
 
    $filename = "tree" ;
    unlink $filename ;
 
    # Enable duplicate records
    $DB_BTREE->{'flags'} = R_DUP ;
 
    tie %h, "DB_File", $filename, O_RDWR|O_CREAT, 0640, $DB_BTREE 
	or die "Cannot open $filename: $!\n";
 
    # Add some key/value pairs to the file
    $h{'Wall'} = 'Larry' ;
    $h{'Wall'} = 'Brick' ; # Note the duplicate key
    $h{'Smith'} = 'John' ;
    $h{'mouse'} = 'mickey' ;

    # iterate through the associative array
    # and print each key/value pair.
    foreach (keys %h)
      { print "$_  -> $h{$_}\n" }

Here is the output:

    Smith   -> John
    Wall    -> Larry
    Wall    -> Larry
    mouse   -> mickey

As you can see 2 records have been succesfully created with key C<Wall>
- the only thing is, when they are retrieved from the database they
both I<seem> to have the same value, namely C<Larry>. The problem is
caused by the way that the associative array interface works.
Basically, when the associative array interface is used to fetch the
value associated with a given key, it will only ever retrieve the first
value.

Although it isn't immediately obvious from the code above, the
associative array interface can be used to write values with duplicate
keys, but it cannot be used to read them back from the database.

The way to get around this problem is to use the Berkeley DB API method
called C<seq>.  This method allows sequential access to key/value
pairs.  See L<"Using the Berkeley DB API Directly"> for details of both
the C<seq> method and the API in general.

Here is the script above rewritten using the C<seq> API method.

    use DB_File ;
    use Fcntl ;
 
    $filename = "tree" ;
    unlink $filename ;
 
    # Enable duplicate records
    $DB_BTREE->{'flags'} = R_DUP ;
 
    $x = tie %h, "DB_File", $filename, O_RDWR|O_CREAT, 0640, $DB_BTREE 
	or die "Cannot open $filename: $!\n";
 
    # Add some key/value pairs to the file
    $h{'Wall'} = 'Larry' ;
    $h{'Wall'} = 'Brick' ; # Note the duplicate key
    $h{'Smith'} = 'John' ;
    $h{'mouse'} = 'mickey' ;
 
    # Point to the first record in the btree 
    $x->seq($key, $value, R_FIRST) ;

    # now iterate through the rest of the btree
    # and print each key/value pair.
    print "$key     -> $value\n" ;
    while ( $x->seq($key, $value, R_NEXT) == 0)
      {  print "$key -> $value\n" }
 
    undef $x ;
    untie %h ;

that prints:

    Smith   -> John
    Wall    -> Brick
    Wall    -> Larry
    mouse   -> mickey

This time we have got all the key/value pairs, including both the
values associated with the key C<Wall>.

C<DB_File> comes with a utility method, called C<get_dup>, to assist in
reading duplicate values from BTREE databases. The method can take the
following forms:

    $count = $x->get_dup($key) ;
    @list  = $x->get_dup($key) ;
    %list  = $x->get_dup($key, 1) ;

In a scalar context the method returns the number of values associated
with the key, C<$key>.

In list context, it returns all the values which match C<$key>. Note
that the values returned will be in an apparently random order.

If the second parameter is present and evaluates TRUE, the method
returns an associative array whose keys correspond to the the values
from the BTREE and whose values are all C<1>.

So assuming the database created above, we can use C<get_dups> like
this:

    $cnt  = $x->get_dups("Wall") ;
    print "Wall occured $cnt times\n" ;

    %hash = $x->get_dups("Wall", 1) ;
    print "Larry is there\n" if $hash{'Larry'} ;

    @list = $x->get_dups("Wall") ;
    print "Wall =>	[@list]\n" ;

    @list = $x->get_dups("Smith") ;
    print "Smith =>	[@list]\n" ;
 
    @list = $x->get_dups("Dog") ;
    print "Dog =>	[@list]\n" ;


and it will print:

    Wall occured 2 times
    Larry is there
    Wall =>	[Brick Larry]
    Smith =>	[John]
    Dog =>	[]

=item B<3.>

B<Locking>

Berkeley DB doesn't support locking itself.

=back

=head1 VERSION

1.0 20th May 1996
