.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
.ds L' '
.ds R' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds L' `
.ds R' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH DB_FILE 1 "perl " "17/May/96" "User Contributed Perl Documentation"
.IX Title "DB_FILE 1"
.UC
.IX Name "DB_File - Perl5 access to Berkeley DB"
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
.IX Header "NAME"
DB_File \- Perl5 access to Berkeley DB
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.PP
.Vb 15
\& use DB_File ;
\&  
\& [$X =] tie %hash,  DB_File, [$filename, $flags, $mode, $DB_HASH] ;
\& [$X =] tie %hash,  DB_File, $filename, $flags, $mode, $DB_BTREE ;
\& [$X =] tie @array, DB_File, $filename, $flags, $mode, $DB_RECNO ;
\&   
\& $status = $X->del($key [, $flags]) ;
\& $status = $X->put($key, $value [, $flags]) ;
\& $status = $X->get($key, $value [, $flags]) ;
\& $status = $X->seq($key, $value [, $flags]) ;
\& $status = $X->sync([$flags]) ;
\& $status = $X->fd ;
\&    
\& untie %hash ;
\& untie @array ;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\fBDB_File\fR is a module which allows Perl programs to make use of the
facilities provided by Berkeley DB.  If you intend to use this
module you should really have a copy of the Berkeley DB manualpage at
hand. The interface defined here mirrors the Berkeley DB interface
closely.
.PP
Berkeley DB is a C library which provides a consistent interface to a
number of database formats.  \fBDB_File\fR provides an interface to all
three of the database types currently supported by Berkeley DB.
.PP
The file types are:
.Ip "\s-1DB_HASH\s0" 5
.IX Item "\s-1DB_HASH\s0"
This database type allows arbitrary key/data pairs to be stored in data
files. This is equivalent to the functionality provided by other
hashing packages like \s-1DBM\s0, \s-1NDBM\s0, \s-1ODBM\s0, \s-1GDBM\s0, and \s-1SDBM\s0. Remember though,
the files created using \s-1DB_HASH\s0 are not compatible with any of the
other packages mentioned.
.Sp
A default hashing algorithm, which will be adequate for most
applications, is built into Berkeley \s-1DB\s0. If you do need to use your own
hashing algorithm it is possible to write your own in Perl and have
\fBDB_File\fR use it instead.
.Ip "\s-1DB_BTREE\s0" 5
.IX Item "\s-1DB_BTREE\s0"
The btree format allows arbitrary key/data pairs to be stored in a
sorted, balanced binary tree.
.Sp
As with the \s-1DB_HASH\s0 format, it is possible to provide a user defined
Perl routine to perform the comparison of keys. By default, though, the
keys are stored in lexical order.
.Ip "\s-1DB_RECNO\s0" 5
.IX Item "\s-1DB_RECNO\s0"
\s-1DB_RECNO\s0 allows both fixed-length and variable-length flat text files
to be manipulated using the same key/value pair interface as in \s-1DB_HASH\s0
and \s-1DB_BTREE\s0.  In this case the key will consist of a record (line)
number.
.Sh "How does DB_File interface to Berkeley \s-1DB\s0?"
.IX Subsection "How does DB_File interface to Berkeley \s-1DB\s0?"
\fBDB_File\fR allows access to Berkeley \s-1DB\s0 files using the \fItie()\fR mechanism
in Perl 5 (for full details, see the \f(CWtie()\fR entry in the \fIperlfunc\fR manpage). This facility
allows \fBDB_File\fR to access Berkeley \s-1DB\s0 files using either an
associative array (for \s-1DB_HASH\s0 & \s-1DB_BTREE\s0 file types) or an ordinary
array (for the \s-1DB_RECNO\s0 file type).
.PP
In addition to the \fItie()\fR interface, it is also possible to access most
of the functions provided in the Berkeley \s-1DB\s0 \s-1API\s0 directly.
.Sh "Differences with Berkeley \s-1DB\s0"
.IX Subsection "Differences with Berkeley \s-1DB\s0"
Berkeley \s-1DB\s0 uses the function \fIdbopen()\fR to open or create a database.
Below is the C prototype for \fIdbopen()\fR.
.PP
.Vb 3
\&      DB*
\&      dbopen (const char * file, int flags, int mode, 
\&              DBTYPE type, const void * openinfo)
.Ve
The parameter \f(CWtype\fR is an enumeration which specifies which of the 3
interface methods (\s-1DB_HASH\s0, \s-1DB_BTREE\s0 or \s-1DB_RECNO\s0) is to be used.
Depending on which of these is actually chosen, the final parameter,
\fIopeninfo\fR points to a data structure which allows tailoring of the
specific interface method.
.PP
This interface is handled slightly differently in \fBDB_File\fR. Here is
an equivalent call using \fBDB_File\fR.
.PP
.Vb 1
\&        tie %array, DB_File, $filename, $flags, $mode, $DB_HASH ;
.Ve
The \f(CWfilename\fR, \f(CWflags\fR and \f(CWmode\fR parameters are the direct
equivalent of their \fIdbopen()\fR counterparts. The final parameter \f(CW$DB_HASH\fR
performs the function of both the \f(CWtype\fR and \f(CWopeninfo\fR parameters in
\fIdbopen()\fR.
.PP
In the example above \f(CW$DB_HASH\fR is actually a reference to a hash
object. \fBDB_File\fR has three of these pre-defined references. Apart
from \f(CW$DB_HASH\fR, there is also \f(CW$DB_BTREE\fR and \f(CW$DB_RECNO\fR.
.PP
The keys allowed in each of these pre-defined references is limited to
the names used in the equivalent C structure. So, for example, the
\f(CW$DB_HASH\fR reference will only allow keys called \f(CWbsize\fR, \f(CWcachesize\fR,
\f(CWffactor\fR, \f(CWhash\fR, \f(CWlorder\fR and \f(CWnelem\fR.
.PP
To change one of these elements, just assign to it like this
.PP
.Vb 1
\&        $DB_HASH->{cachesize} = 10000 ;
.Ve
It is possible to omit some of the final 4 parameters in the call to
\f(CWtie\fR and let them take default values. As the \s-1DB_HASH\s0 is the most
common file format used, the call:
.PP
.Vb 1
\&    tie %A, DB_File, "filename" ;
.Ve
is equivalent to:
.PP
.Vb 1
\&    tie %A, DB_File, "filename", O_RDWR, 0640, $DB_HASH ;
.Ve
Note that the default parameters assume you are accessing an existsing
file. When creating a \s-1DB\s0 file the flags O_RDWR abd O_CREAT must be
specified, like this:
.PP
.Vb 1
\&    tie %A, DB_File, "filename", O_RDWR|O_CREAT ;
.Ve
It is also possible to omit the filename parameter as well, so the
call:
.PP
.Vb 1
\&    tie %A, DB_File ;
.Ve
is equivalent to:
.PP
.Vb 1
\&    tie %A, DB_File, undef, O_RDWR, 0640, $DB_HASH ;
.Ve
See the section on \fI/"In Memory Databases\fR below for 
.Sh "\s-1RECNO\s0"
.IX Subsection "\s-1RECNO\s0"
In order to make \s-1RECNO\s0 more compatible with Perl the array offset for all
\s-1RECNO\s0 arrays begins at 0 rather than 1 as in Berkeley \s-1DB\s0.
.Sh "In Memory Databases"
.IX Subsection "In Memory Databases"
Berkeley \s-1DB\s0 allows the creation of in-memory databases by using \s-1NULL\s0
(that is, a \f(CW(char *)0\fR in C) in place of the filename.  \fBDB_File\fR
uses \f(CWundef\fR instead of \s-1NULL\s0 to provide this functionality.
.Sh "Using the Berkeley \s-1DB\s0 Interface Directly"
.IX Subsection "Using the Berkeley \s-1DB\s0 Interface Directly"
As well as accessing Berkeley \s-1DB\s0 using a tied hash or array, it is also
possible to make direct use of most of the functions defined in the
Berkeley \s-1DB\s0 documentation.
.PP
To do this you need to remember the return value from the tie.
.PP
.Vb 1
\&        $db = tie %hash, DB_File, "filename"
.Ve
Once you have done that, you can access the Berkeley \s-1DB\s0 \s-1API\s0 functions
directly.
.PP
.Vb 1
\&        $db->put($key, $value, R_NOOVERWRITE) ;
.Ve
All the functions defined in the \fIdbx(3X)\fR manpage are available except for
\fIclose()\fR and \fIdbopen()\fR itself. The \fBDB_File\fR interface to these
functions have been implemented to mirror the way Berkeley \s-1DB\s0
works. In particular note that all the functions return only a status
value. Whenever a Berkeley \s-1DB\s0 function returns data via one of its
parameters, the \fBDB_File\fR equivalent does exactly the same.
.PP
All the constants defined in the \fIdbopen\fR manpage are also available.
.PP
Below is a list of the functions available.
.Ip "get" 5
.IX Item "get"
Same as in \f(CWrecno\fR except that the flags parameter is optional.
Remember the value associated with the key you request is returned in
the \f(CW$value\fR parameter.
.Ip "put" 5
.IX Item "put"
As usual the flags parameter is optional. 
.Sp
If you use either the R_IAFTER or R_IBEFORE flags, the key parameter
will have the record number of the inserted key/value pair set.
.Ip "del" 5
.IX Item "del"
The flags parameter is optional.
.Ip "fd" 5
.IX Item "fd"
As in \fIrecno\fR.
.Ip "seq" 5
.IX Item "seq"
The flags parameter is optional.
.Sp
Both the key and value parameters will be set.
.Ip "sync" 5
.IX Item "sync"
The flags parameter is optional.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
It is always a lot easier to understand something when you see a real
example. So here are a few.
.Sh "Using \s-1HASH\s0"
.IX Subsection "Using \s-1HASH\s0"
.PP
.Vb 15
\&        use DB_File ;
\&        use Fcntl ;
\&        
\&        tie %h,  "DB_File", "hashed", O_RDWR|O_CREAT, 0640, $DB_HASH ;
\&        
\&        # Add a key/value pair to the file
\&        $h{"apple"} = "orange" ;
\&        
\&        # Check for existence of a key
\&        print "Exists\en" if $h{"banana"} ;
\&        
\&        # Delete 
\&        delete $h{"apple"} ;
\&        
\&        untie %h ;
.Ve
.Sh "Using \s-1BTREE\s0"
.IX Subsection "Using \s-1BTREE\s0"
Here is sample of code which used \s-1BTREE\s0. Just to make life more
interesting the default comparision function will not be used. Instead
a Perl sub, \f(CWCompare()\fR, will be used to do a case insensitive
comparison.
.PP
.Vb 30
\&        use DB_File ;
\&        use Fcntl ;
\&         
\&        sub Compare
\&        {
\&            my ($key1, $key2) = @_ ;
\&        
\&            "\eL$key1" cmp "\eL$key2" ;
\&        }
\&        
\&        $DB_BTREE->{compare} = 'Compare' ;
\&         
\&        tie %h,  'DB_File', "tree", O_RDWR|O_CREAT, 0640, $DB_BTREE ;
\&         
\&        # Add a key/value pair to the file
\&        $h{'Wall'} = 'Larry' ;
\&        $h{'Smith'} = 'John' ;
\&        $h{'mouse'} = 'mickey' ;
\&        $h{'duck'}   = 'donald' ;
\&         
\&        # Delete
\&        delete $h{"duck"} ;
\&         
\&        # Cycle through the keys printing them in order.
\&        # Note it is not necessary to sort the keys as
\&        # the btree will have kept them in order automatically.
\&        foreach (keys %h)
\&          { print "$_\en" }
\&        
\&        untie %h ;
.Ve
Here is the output from the code above.
.PP
.Vb 3
\&        mouse
\&        Smith
\&        Wall
.Ve
.Sh "Using \s-1RECNO\s0"
.IX Subsection "Using \s-1RECNO\s0"
.PP
.Vb 14
\&        use DB_File ;
\&        use Fcntl ;
\&        
\&        $DB_RECNO->{psize} = 3000 ;
\&        
\&        tie @h,  DB_File, "text", O_RDWR|O_CREAT, 0640, $DB_RECNO ;
\&        
\&        # Add a key/value pair to the file
\&        $h[0] = "orange" ;
\&        
\&        # Check for existence of a key
\&        print "Exists\en" if $h[1] ;
\&        
\&        untie @h ;
.Ve
.Sh "Locking Databases"
.IX Subsection "Locking Databases"
Concurrent access of a read-write database by several parties requires
them all to use some kind of locking.  Here's an example of Tom's that
uses the \fIfd\fR method to get the file descriptor, and then a careful
\fIopen()\fR to give something Perl will \fIflock()\fR for you.  Run this repeatedly
in the background to watch the locks granted in proper order.
.PP
.Vb 2
\&    use Fcntl;
\&    use DB_File;
.Ve
.Vb 1
\&    use strict;
.Ve
.Vb 4
\&    sub LOCK_SH { 1 }
\&    sub LOCK_EX { 2 }
\&    sub LOCK_NB { 4 }
\&    sub LOCK_UN { 8 }
.Ve
.Vb 1
\&    my($oldval, $fd, $db, %db, $value, $key);
.Ve
.Vb 2
\&    $key = shift || 'default';
\&    $value = shift || 'magic';
.Ve
.Vb 1
\&    $value .= " $$";
.Ve
.Vb 5
\&    $db = tie(%db, 'DB_File', '/tmp/foo.db', O_CREAT|O_RDWR, 0644) 
\&            || die "dbcreat /tmp/foo.db $!";
\&    $fd = $db->fd;
\&    print "$$: db fd is $fd\en";
\&    open(DB_FH, "+<&=$fd") || die "dup $!";
.Ve
.Vb 6
\&    unless (flock (DB_FH, LOCK_SH | LOCK_NB)) {
\&        print "$$: CONTENTION; can't read during write update!
\&                    Waiting for read lock ($!) ....";
\&        unless (flock (DB_FH, LOCK_SH)) { die "flock: $!" }
\&    } 
\&    print "$$: Read lock granted\en";
.Ve
.Vb 3
\&    $oldval = $db{$key};
\&    print "$$: Old value was $oldval\en";
\&    flock(DB_FH, LOCK_UN);
.Ve
.Vb 5
\&    unless (flock (DB_FH, LOCK_EX | LOCK_NB)) {
\&        print "$$: CONTENTION; must have exclusive lock!
\&                    Waiting for write lock ($!) ....";
\&        unless (flock (DB_FH, LOCK_EX)) { die "flock: $!" }
\&    } 
.Ve
.Vb 3
\&    print "$$: Write lock granted\en";
\&    $db{$key} = $value;
\&    sleep 10;
.Ve
.Vb 4
\&    flock(DB_FH, LOCK_UN);
\&    untie %db;
\&    close(DB_FH);
\&    print "$$: Updated db to $key=$value\en";
.Ve
.SH "HISTORY"
.IX Header "HISTORY"
.Ip "0.1" 5
.IX Item "0.1"
First Release.
.Ip "0.2" 5
.IX Item "0.2"
When \fBDB_File\fR is opening a database file it no longer terminates the
process if \fIdbopen\fR returned an error. This allows file protection
errors to be caught at run time. Thanks to Judith Grass
<grass@cybercash.com> for spotting the bug.
.Ip "0.3" 5
.IX Item "0.3"
Added prototype support for multiple btree compare callbacks.
.Ip "1.0" 5
.IX Item "1.0"
\fBDB_File\fR has been in use for over a year. To reflect that, the
version number has been incremented to 1.0.
.Sp
Added complete support for multiple concurrent callbacks.
.Sp
Using the \fIpush\fR method on an empty list didn't work properly. This
has been fixed.
.Ip "1.01" 5
.IX Item "1.01"
Fixed a core dump problem with SunOS.
.Sp
The return value from \s-1TIEHASH\s0 wasn't set to \s-1NULL\s0 when dbopen returned
an error.
.Ip "1.02" 5
.IX Item "1.02"
Tidied up some code.
.Sp
Documentation update.
.SH "WARNINGS"
.IX Header "WARNINGS"
If you happen find any other functions defined in the source for this
module that have not been mentioned in this document -- beware.  I may
drop them at a moments notice.
.Sp
If you cannot find any, then either you didn't look very hard or the
moment has passed and I have dropped them.
.SH "BUGS"
.IX Header "BUGS"
Some older versions of Berkeley DB had problems with fixed length
records using the RECNO file format. The newest version at the time of
writing was 1.85 \- this seems to have fixed the problems with RECNO.
.Sp
I am sure there are bugs in the code. If you do find any, or can
suggest any enhancements, I would welcome your comments.
.SH "AVAILABILITY"
.IX Header "AVAILABILITY"
Berkeley DB is available at your nearest CPAN archive (see
the section on \fICPAN\fR in the \fIperlmod\fR manpage for a list) in \fIsrc/misc/db.1.85.tar.gz\fR, or via the
host \fIftp.cs.berkeley.edu\fR in \fI/ucb/4bsd/db.tar.gz\fR.  It is \fInot\fR under
the GPL.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
the \fIperl(1)\fR manpage, the \fIdbopen(3)\fR manpage, the \fIhash(3)\fR manpage, the \fIrecno(3)\fR manpage, the \fIbtree(3)\fR manpage 
.Sp
Berkeley DB is available from \fIftp.cs.berkeley.edu\fR in the directory
\fI/ucb/4bsd\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
The DB_File interface was written by Paul Marquess
<pmarquess@bfsec.bt.co.uk>.
Questions about the DB system itself may be addressed to Keith Bostic
<bostic@cs.berkeley.edu>.

.rn }` ''
