
die "Usage: $0 count\n"
    unless @ARGV == 1 and $ARGV[0] =~ /^\s*\d+\s*$/ ;

$BTREE_CALLBACKS = $ARGV[0] ;

print <<EOM ;

#define BTREE_CALLBACKS	$BTREE_CALLBACKS

EOM

foreach $index (0 .. $BTREE_CALLBACKS - 1)
{
    print <<EOM ;
static int  btree_fn$index _((const DBT * key1, const DBT * key2)) ;
EOM
}


print <<EOM ;

static CallBackInfo btree_callbacks [BTREE_CALLBACKS] =
    {
EOM

foreach $index (0 .. $BTREE_CALLBACKS - 1)
{
    print <<EOM ;
        { btree_fn$index, NULL},
EOM
}

print <<EOM ;
    } ;

EOM


foreach $index (0 .. $BTREE_CALLBACKS - 1)
{
    print <<EOM ;

static int
btree_fn$index(key1, key2)
const DBT * key1 ;
const DBT * key2 ;
{
    return (btree_compare($index, key1, key2)) ;
}
EOM
}

#void
#array_asynch_read(fh, callback)
#    int		fh
#    SV *	callback
#    CODE:
#    int index ;
#    int null_index = MAX_CB ;
#
#    /* Find the same handle or an empty entry */
#    for (index = 0 ; index < MAX_CB ; ++index)
#    {
#        if (Map[index].Handle == fh)
#            break ;
#
#        if (Map[index].Handle == NULL_HANDLE)
#            null_index = index ;
#    }
#
#    if (index == MAX_CB && null_index == MAX_CB)
#        croak ("Too many callback functions registered\n") ;
#
#    if (index == MAX_CB)
#        index = null_index ;
#
#    /* Save the file handle */
#    Map[index].Handle = fh ;
#
#    /* Remember the Perl sub */
#    if (Map[index].PerlSub == (SV*)NULL)
#        Map[index].PerlSub = newSVsv(callback) ;
#    else
#        SvSetSV(Map[index].PerlSub, callback) ;
#
#    asynch_read(fh, Map[index].Function) ;
#
#void
#array_asynch_close(fh)
#    int	fh
#    CODE:
#    int index ;
#
#    /* Find the file handle */
#    for (index = 0; index < MAX_CB ; ++ index)
#        if (Map[index].Handle == fh)
#            break ;
#
#    if (index == MAX_CB)
#        croak ("could not close fh %d\n", fh) ;
#
#    Map[index].Handle = NULL_HANDLE ;
#    SvREFCNT_dec(Map[index].PerlSub) ;
#    Map[index].PerlSub = (SV*)NULL ;
#
#    asynch_close(fh) ;
#
#EOM
