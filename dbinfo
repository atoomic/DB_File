
# Print stats on a db file

use FileHandle ;

$BTREEMAGIC      = 0x053162 ;
$HASHMAGIC       = 0x061561 ;

print "testing $ARGV[0]\n" ;
$F = new FileHandle "<$ARGV[0]" or die "Cannot open file $ARGV[0]: $!\n" ;

read $F, $buff, 4 ;
$magic = unpack("N", $buff) ;

HashInfo($F) if $magic == $HASHMAGIC ;
BtreeInfo($F) if $magic == $BTREEMAGIC ;

close $F ;

exit ;

sub HashInfo
{
    my $fh = shift ;
    my $header_str = "N18" ;
    my 
    my $header_len = length $header_str ;

    read $F, $buff, 72 ;
    @v = unpack($header_str, $buff) ;

print <<EOM ;
Berkeley DB Hash File

Magic NO for hash tables $HASHMAGIC
Database Version ID      $v[0]
Byte Order (lorder)      $v[1]
Bucket Size (bsize)      $v[2]
Bucket shift 		 $v[3]
Directory Size 		 $v[4]
Segment Size 		 $v[5]
Segment shift 		 $v[6]
Fill factor (ffactor)	 $v[12]
Number of keys in hash 	 $v[13]
Size of table header 	 $v[14]
value of hash(CHARKEY) 	 $v[15]

EOM

}
sub BtreeInfo
{
    my $fh = shift ;
    my $header_str = "N6" ;
    my 
    my $header_len = length $header_str ;

    read $F, $buff, 24 ;
    @v = unpack($header_str, $buff) ;

print <<EOM ;
Berkeley DB Btree File

magic;          /* magic number */ $BTREEMAGIC ;
version;        /* version */	$v[0]
psize;          /* page size */	$v[1]
free;           /* page number of first free page */	$v[2]
nrecs;          /* R: number of records */	$v[3]

flags;          /* bt_flags & SAVEMETA */	$v[4]

EOM

}

print "A Berkeley DB Hash file\n" if $magic == $HASHMAGIC ;
print "A Berkeley DB Btree file\n" if $magic == $BTREEMAGIC ;

#if($bytes0_3 eq "\x00\x06\x15\x61")
#{
#local ($string) = "Berkeley DB Hash" ;
#return $string . " data";
#}
#if ($bytes0_3 eq "\x00\x05\x31\x62")
#{
#local ($string) = "Berkeley DB Btree" ;
#return $string . " data";
#}


#$HASH_STR = "I18 S" ;

#/* Hash Table Information */
#typedef struct hashhdr {                /* Disk resident portion */
#        int             magic;          /* Magic NO for hash tables */
#        int             version;        /* Version ID */
#        u_int32_t       lorder;         /* Byte Order */
#        int             bsize;          /* Bucket/Page Size */
#        int             bshift;         /* Bucket shift */
#        int             dsize;          /* Directory Size */
#        int             ssize;          /* Segment Size */
#        int             sshift;         /* Segment shift */
#        int             ovfl_point;     /* Where overflow pages are being
#                                         * allocated */
#        int             last_freed;     /* Last overflow page freed */
#        int             max_bucket;     /* ID of Maximum bucket in use */
#        int             high_mask;      /* Mask to modulo into entire table */
#        int             low_mask;       /* Mask to modulo into lower half of
#                                         * table */
#        int             ffactor;        /* Fill factor */
#        int             nkeys;          /* Number of keys in hash table */
#        int             hdrpages;       /* Size of table header */
#        int             h_charkey;      /* value of hash(CHARKEY) */
##define NCACHED 32                      /* number of bit maps and spare
#                                         * points */
#        int             spares[NCACHED];/* spare pages for overflow */
#        u_int16_t       bitmaps[NCACHED];       /* address of overflow page
#                                                 * bitmaps */
#} HASHHDR;
#



#/*
# * The metadata of the tree.  The nrecs field is used only by the RECNO code.
# * This is because the btree doesn't really need it and it requires that every
# * put or delete call modify the metadata.
# */
#typedef struct _btmeta {
#        u_int32_t       magic;          /* magic number */
#        u_int32_t       version;        /* version */
#        u_int32_t       psize;          /* page size */
#        u_int32_t       free;           /* page number of first free page */
#        u_int32_t       nrecs;          /* R: number of records */
#
##define SAVEMETA        (B_NODUPS | R_RECNO)
#        u_int32_t       flags;          /* bt_flags & SAVEMETA */
#} BTMETA;
#
