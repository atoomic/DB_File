Subject: Configure-like support in Makefile.PL

I want to allow DB_File to be built away from the Perl source tree like
any other external module. The problem is, DB_File assumes that
Configure has already figured out a few things about the version of
Berkeley DB that is installed.

To do what Configure currently does for DB_File, I needed a simple Perl
module that could do the following:

    1. check for the existance of a given header file, db.h in this
       case.

    2. check for the existance of a given library, libdb.[a|so].

    3. compile (and optionally run) a piece of C source.

    4. check if an external module has already been installed in a
       place that will be found first in the @INC path.

As all of these features are of general use, I thought I would share
what I have done with you all.

Below is a first stab at a module which can do the first 3 things
listed above. The last one I haven't addressed. Most of what is
included was either a direct rewrite of the equivalent functionality in
Configure or borrowed from some other existing modules (Tk).

I have also included a sample script that could potentially be used to
add Configure support for DB_File.

Should this functionality be merged into MakeMaker? or is a separate
module the way to go?

Does anyone have the time to take this on?

Paul


#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of shell archive."
# Contents:  Dist.pm cfig
# Wrapped by pmarques@claudius on Wed Sep  4 11:13:27 1996
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Dist.pm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Dist.pm'\"
else
echo shar: Extracting \"'Dist.pm'\" \(4841 characters\)
sed "s/^X//" >'Dist.pm' <<'END_OF_FILE'
X
Xpackage Dist ;
X
Xuse strict ;
Xuse Config ;
Xuse IO::Pipe ;
Xuse IO::File ;
Xuse ExtUtils::MakeMaker ;
X
Xuse vars qw( @EXPORT @ISA $fieldn) ;
X
X
X
Xsub new
X{
X    my ($pkg) = shift ;
X    bless { %Config }, $pkg ;
X}
X
Xsub writeFile
X{
X    my ($self) = shift ;
X    my ($filename, $string) = @_ ;
X    my $fh = new IO::File ">$filename"
X    	or die "Cannot open file '$filename': $!\n" ;
X
X    print $fh $string ;
X    $fh->close ;
X
X}
X
Xsub fieldn
X{
X    my ($self) = shift ;
X    my $pos ;
X    my $field ;
X    my ($CPP) = "$self->{'cppstdin'}  $self->{'cppminus'} " . 
X		"$self->{'cppflags'} 2>/dev/null" ;
X
X    return $fieldn if defined $fieldn ;
X
X    #print "Computing filename position in cpp output for #include directives...\n"; 
X    # determine filename position in cpp output
X    my $pipe = new IO::Pipe ;
X    $pipe->reader("echo '#include <stdio.h>' | $CPP") ;
X
X    LOOP:
X    while (<$pipe>) {
X	next unless /^\s*#.*stdio\.h/ ;
X	$pos = 0 ;
X	foreach $field (split) {
X	    $field =~ tr/"//d ;
X	    last LOOP if -r $field ;
X	    ++ $pos ;
X	}
X	
X    }
X    $pipe->close ;
X
X    #print "Your cpp writes the filename in field $pos of the line.\n";
X    return $pos ;
X}
X
X
Xsub findhdr
X{
X    my ($self) = shift ;
X    my ($wanted) = shift ;
X    my ($usrinc) = $self->{'usrinc'} ;
X    my $name ;
X    my $CPP = $self->{'cppstdin'} . " " . $self->{'cppminus'} . " " . 
X		$self->{'cppflags'} . "  2>/dev/null" ;
X
X    # First the easy way
X    return "$usrinc/$wanted" 
X	if -f "$usrinc/$wanted" ;
X
X
X    my $pipe = new IO::Pipe ;
X    my ($fieldn) = $self->fieldn() ;
X    $pipe->reader("echo '#include <$wanted>' | $CPP") ;
X
X    while (<$pipe>) {
X	next unless /^\s*#.*$wanted/ ;
X	#print "findhdr: [$_]" ;
X	$name = (split)[$fieldn] ;
X
X	if ($name =~ /$wanted/ ) {
X	    $pipe->close ; 
X	    $name =~ s/"//g ;
X	    return $name ;
X	}
X    }
X
X    $pipe->close ;
X
X    return undef ;
X}
X
X
Xsub compile
X{
X    my ($self) = shift ;
X    my ($file) = shift ;
X
X    print "$self->{'cc'} $self->{'ccflags'} -c $file 2>&1\n" ;
X    `$self->{'cc'} $self->{'ccflags'} -c $file 2>&1` ;
X}
X 
Xsub compile_and_run
X{
X    my ($self) = shift ;
X    my $string  = shift;
X    my $file  = "try" ;
X    my $msgs ;
X    my $status ;
X
X    $self->writeFile("$file.c", $string) ;
X    $msgs = `$self->{'cc'} $self->{'ccflags'} $file.c $self->{'ldflags'} 2>&1` ;
X    $status = $? >> 8 ;
X    #print "msg = [$msgs] \$?=[$?]\n" ;
X    if ($? >>8 == 0)
X    {
X        $msgs = `a.out` ;
X        $status = $? >> 8 ;
X    }
X    unlink('a.out') if (-f 'a.out');
X    unlink (<$file.*>) ;
X    return ($status , $msgs) ;
X}
X 
X 
X
Xsub BerkeleyDB_hash_type
X{
X    my ($self) = shift ;
X    my $HAS_CONST ;
X    my $db_hashtype ;
X
X    $HAS_CONST = "#define HASCONST" if $self->{'d_const'} ;
X
X    # Check the return type needed for hash
X    print "\nChecking return type needed for hash for Berkeley DB ...\n" ;
X
X    $self->writeFile ('try.c', <<EOCP) ;
X 
X$HAS_CONST
X#ifndef HASCONST
X#define const
X#endif
X#include <sys/types.h>
X#include <db.h>
Xu_int32_t hash_cb (ptr, size)
Xconst void *ptr;
Xsize_t size;
X{
X}
XHASHINFO info;
Xmain()
X{
X        info.hash = hash_cb;
X}
XEOCP
X     
X    $_ = $self->compile("try.c") ;
X    if ($? >> 8 == 0) {
X        if (/warning/)
X          { $db_hashtype='int' }
X        else
X          { $db_hashtype='u_int32_t' }
X    }
X    else {
X        print "I can't seem to compile the test program.\n" ;
X        $db_hashtype='int' ;
X    }
X     
X    unlink <try.*> ;
X     
X    print "Your version of Berkeley DB uses $db_hashtype for hash.\n" ;
X
X    return "-DDB_Prefix_t=$db_hashtype" ;
X
X}
X
Xsub BerkeleyDB_prefix_type
X{
X    my ($self) = shift ;
X    my $HAS_CONST ;
X    my $db_prefixtype ;
X
X    $HAS_CONST = "#define HASCONST" if $self->{'d_const'} ;
X    print "\nChecking return type needed for prefix for Berkeley DB ...\n" ;
X
X    $self->writeFile('try.c', <<EOCP) ;
X$HAS_CONST
X#ifndef HASCONST
X#define const
X#endif
X#include <sys/types.h>
X#include <db.h>
Xsize_t prefix_cb (key1, key2)
Xconst DBT *key1;
Xconst DBT *key2;
X{
X}
XBTREEINFO info;
Xmain()
X{
X        info.prefix = prefix_cb;
X}
XEOCP
X     
X    $_ = $self->compile("try.c") ;
X    if ($? >> 8 == 0) {
X        if (/warning/)
X          { $db_prefixtype='int' }
X        else
X          { $db_prefixtype='size_t' }
X    }
X    else {
X        print "I can't seem to compile the test program.\n" ;
X        $db_prefixtype='int' ;
X    }
X     
X    unlink <try.*> ;
X    print "Your version of Berkeley DB uses $db_prefixtype for prefix.\n" ;
X
X    return "-DDB_Hash_t=$db_prefixtype" ;
X}
X
X
Xsub chkLib
X{
X    my ($self) = shift ;
X
X    my $x = new ExtUtils::MakeMaker ;
X    $x->ext("@_") ;
X}
X
X
Xsub ModuleInstalled
X{
X    my ($self) = shift ;
X    my ($module) = shift ;
X    my ($module_path) ;
X    my (@conflict) ;
X
X    ($module_path = $module) =~ s#::#/#g ;
X
X    foreach (@INC) {
X        next if(/site_perl/);
X        push (@conflict, $_) if -e "$_/$module_path.pm" ;
X    }
X
X    
X    
X}
X
X1;
END_OF_FILE
if test 4841 -ne `wc -c <'Dist.pm'`; then
    echo shar: \"'Dist.pm'\" unpacked with wrong size!
fi
# end of 'Dist.pm'
fi
if test -f 'cfig' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cfig'\"
else
echo shar: Extracting \"'cfig'\" \(683 characters\)
sed "s/^X//" >'cfig' <<'END_OF_FILE'
X
Xuse Dist ;
X
X
X
X$header = "db.h" ;
X$library = "db" ;
X$module  = "DB_File" ;
X
X$dist = new Dist ;
X
X# see if this is a db.h system
Xprint "\nChecking for $header...\n" ;
Xmy $x = $dist->findhdr ($header) ;
X
Xif ($x) 
X  { print "Found it at $x\n" }
Xelse {
X    print "Could not find it.\n" ;
X    exit 1 ;
X}
X
X# check for libdb
Xprint "\nChecking for library lib$library...\n" ;
X@a = $dist->chkLib("-l$library") ;
Xif ($a[3])
X  { print "found it in $a[3]\n" }
Xelse {
X    print "could not find it. \n" ;
X    exit 1 ;
X}
X
X# Check the return type needed for hash and prefix
X
X$DEFINE = $dist->BerkeleyDB_hash_type() . " " . 
X          $dist->BerkeleyDB_prefix_type() ;
X
Xprint "DEFINE = [$DEFINE]\n" ;
END_OF_FILE
if test 683 -ne `wc -c <'cfig'`; then
    echo shar: \"'cfig'\" unpacked with wrong size!
fi
# end of 'cfig'
fi
echo shar: End of shell archive.
exit 0
