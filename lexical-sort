#
#/*
# * __BT_DEFCMP -- Default comparison routine.
# *
# * Parameters:
# *      a:      DBT #1
# *      b:      DBT #2
# *
# * Returns:
# *      < 0 if a is < b
# *      = 0 if a is = b
# *      > 0 if a is > b
# */
#int
#__bt_defcmp(a, b)
#        const DBT *a, *b;
#{
#        register size_t len;
#        register u_char *p1, *p2;
#
#        /*
#         * XXX
#         * If a size_t doesn't fit in an int, this routine can lose.
#         * What we need is a integral type which is guaranteed to be
#         * larger than a size_t, and there is no such thing.
#         */
#        len = MIN(a->size, b->size);
#        for (p1 = a->data, p2 = b->data; len--; ++p1, ++p2)
#                if (*p1 != *p2)
#                        return ((int)*p1 - (int)*p2);
#        return ((int)a->size - (int)b->size);
#}
#

sub lexical_sort
{
    my ($a, $b) = @_ ;

    my(@a) = unpack ("C*", $a) ;
    my(@b) = unpack ("C*", $b) ;

    my $len = (@a > @b ? @a : @b) ;
    my $i ;

    foreach $i ( 0 .. $len -1) {
        return $a[$i] - $b[$i] if $a[$i] != $b[$i] ;
    }

    return @a - @b ;
}
